<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <title>Pro B&W Cam</title>
    <link rel="manifest" href="manifest.json">
    <style>
        body, html { margin: 0; padding: 0; background: #000; height: 100%; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: sans-serif; }

        canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        video { display: none; }

        .controls {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            z-index: 10;
        }

        #capture-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: transparent;
            border: 4px solid white;
            outline: none;
            cursor: pointer;
            position: relative;
            transition: transform 0.1s;
        }
        #capture-btn::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 58px; height: 58px;
            background: white;
            border-radius: 50%;
        }
        #capture-btn:active { transform: scale(0.95); }

        #switch-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: rgba(50,50,50,0.5);
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        #loader {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 20;
            font-weight: bold;
            letter-spacing: 1px;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Error Message Display */
        #error-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            text-align: center;
            display: none;
            z-index: 30;
        }

    </style>
</head>
<body>

    <video id="video" autoplay playsinline></video>
    <canvas id="preview-canvas"></canvas>

    <div id="loader">
        <div class="spinner"></div>
        <div>PROCESSING HI-RES</div>
    </div>

    <div id="error-msg"></div>

    <div class="controls">
        <button id="switch-btn">â†»</button>
        <button id="capture-btn"></button>
    </div>

    <script>
        const video = document.getElementById('video');
        const previewCanvas = document.getElementById('preview-canvas');
        const previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });

        const loader = document.getElementById('loader');
        const errorMsg = document.getElementById('error-msg');
        const captureBtn = document.getElementById('capture-btn');
        const switchBtn = document.getElementById('switch-btn');

        let videoDevices = [];
        let currentDeviceIndex = 0;
        let isProcessingPreview = false;
        let currentStream = null;

        // --- 1. Camera Initialization ---
        async function initCamera() {
            try {
                // Initial permission request
                await navigator.mediaDevices.getUserMedia({ video: true });

                // List devices
                const devices = await navigator.mediaDevices.enumerateDevices();
                videoDevices = devices.filter(device => device.kind === 'videoinput');

                if (videoDevices.length === 0) {
                    throw new Error("No cameras found.");
                }

                // Try to find a back camera primarily
                const backIdx = videoDevices.findIndex(d =>
                    d.label.toLowerCase().includes('back') ||
                    d.label.toLowerCase().includes('environment'));

                if (backIdx !== -1) currentDeviceIndex = backIdx;

                startCameraStream();
            } catch (err) {
                showError("Permission denied or no camera found: " + err.message);
            }
        }

        // --- 2. Start Stream with Fallback Strategy ---
        async function startCameraStream() {
            // Stop previous stream if running
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            const deviceId = videoDevices[currentDeviceIndex] ? videoDevices[currentDeviceIndex].deviceId : undefined;

            // Strategy: Try High Res -> Then Medium -> Then Basic
            const constraintsAttempts = [
                // 1. Try 4K (Ideal)
                {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        width: { ideal: 4096 },
                        height: { ideal: 2160 }
                    }
                },
                // 2. Try 1080p (Ideal)
                {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                },
                // 3. Just give me the camera (Fallback)
                {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined
                    }
                }
            ];

            for (const constraints of constraintsAttempts) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    currentStream = stream;
                    video.srcObject = stream;

                    video.onloadedmetadata = () => {
                        errorMsg.style.display = 'none'; // Clear errors
                        // Set canvas to screen size for performance
                        previewCanvas.width = window.innerWidth * window.devicePixelRatio;
                        previewCanvas.height = window.innerHeight * window.devicePixelRatio;

                        if (!isProcessingPreview) {
                            isProcessingPreview = true;
                            requestAnimationFrame(loopPreview);
                        }
                    };
                    return; // Success, exit the loop
                } catch (e) {
                    console.warn("Res attempt failed, trying lower...", e);
                    // Continue to next attempt
                }
            }

            showError("Could not start video source. Hardware not supported.");
        }

        function showError(msg) {
            errorMsg.innerText = msg;
            errorMsg.style.display = 'block';
        }

        switchBtn.addEventListener('click', () => {
            if (videoDevices.length > 1) {
                currentDeviceIndex = (currentDeviceIndex + 1) % videoDevices.length;
                startCameraStream();
            }
        });

        // --- 3. Processing Logic (Same as before) ---
        function applyEqualization(ctx, width, height) {
            const frame = ctx.getImageData(0, 0, width, height);
            const data = frame.data;
            const len = data.length;

            const histogram = new Uint32Array(256);
            for (let i = 0; i < len; i += 4) {
                const gray = (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]) | 0;
                data[i] = gray;
                histogram[gray]++;
            }

            const cdf = new Uint32Array(256);
            let sum = 0;
            let minCdf = 0;
            for (let i = 0; i < 256; i++) {
                sum += histogram[i];
                cdf[i] = sum;
                if (minCdf === 0 && sum > 0) minCdf = sum;
            }

            const map = new Uint8Array(256);
            const totalPixels = len / 4;
            const range = totalPixels - minCdf;
            const factor = 255 / (range || 1); // Avoid divide by zero

            for(let i = 0; i < 256; i++) {
                 map[i] = Math.round((cdf[i] - minCdf) * factor);
            }

            for (let i = 0; i < len; i += 4) {
                const val = map[data[i]];
                data[i] = val;
                data[i + 1] = val;
                data[i + 2] = val;
            }
            ctx.putImageData(frame, 0, 0);
        }

        function loopPreview() {
            if (video.paused || video.ended) return;
            previewCtx.drawImage(video, 0, 0, previewCanvas.width, previewCanvas.height);
            applyEqualization(previewCtx, previewCanvas.width, previewCanvas.height);
            requestAnimationFrame(loopPreview);
        }

        // --- 4. High-Res Capture ---
        captureBtn.addEventListener('click', () => {
            loader.style.display = 'flex';

            setTimeout(() => {
                try {
                    const fullWidth = video.videoWidth;
                    const fullHeight = video.videoHeight;

                    const offCanvas = document.createElement('canvas');
                    offCanvas.width = fullWidth;
                    offCanvas.height = fullHeight;
                    const offCtx = offCanvas.getContext('2d');

                    offCtx.drawImage(video, 0, 0, fullWidth, fullHeight);
                    applyEqualization(offCtx, fullWidth, fullHeight);

                    const link = document.createElement('a');
                    const date = new Date().toISOString().replace(/[-:T.]/g, '').slice(0, 14);
                    link.download = `BW_EQ_${date}.jpg`;
                    link.href = offCanvas.toDataURL('image/jpeg', 0.95);
                    link.click();
                } catch (e) {
                    showError("Capture Error: " + e.message);
                } finally {
                    loader.style.display = 'none';
                }
            }, 50);
        });

        if ('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js');

        initCamera();

    </script>
</body>
</html>
